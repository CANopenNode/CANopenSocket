<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CANopenNode: LSS Slave</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CANopenNode
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__CO__LSSslave.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LSS Slave<div class="ingroups"><a class="el" href="group__CO__CANopen__305.html">CANopen_305</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSS slave object.  <a href="structCO__LSSslave__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaba1fafcd0024609f8a72be4810baf66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CO__driver.html#ga1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CO__LSSslave.html#gaaba1fafcd0024609f8a72be4810baf66">CO_LSSslave_init</a> (<a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *LSSslave, <a class="el" href="unionCO__LSS__address__t.html">CO_LSS_address_t</a> *lssAddress, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> *pendingBitRate, <a class="el" href="group__CO__dataTypes.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *pendingNodeID, <a class="el" href="structCO__CANmodule__t.html">CO_CANmodule_t</a> *CANdevRx, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> CANdevRxIdx, <a class="el" href="group__CO__dataTypes.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a> CANidLssMaster, <a class="el" href="structCO__CANmodule__t.html">CO_CANmodule_t</a> *CANdevTx, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> CANdevTxIdx, <a class="el" href="group__CO__dataTypes.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a> CANidLssSlave)</td></tr>
<tr class="memdesc:gaaba1fafcd0024609f8a72be4810baf66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize LSS object.  <a href="group__CO__LSSslave.html#gaaba1fafcd0024609f8a72be4810baf66">More...</a><br /></td></tr>
<tr class="separator:gaaba1fafcd0024609f8a72be4810baf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19d7ad84333f1a3f40ecbdbf639e017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CO__dataTypes.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CO__LSSslave.html#gae19d7ad84333f1a3f40ecbdbf639e017">CO_LSSslave_process</a> (<a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *LSSslave)</td></tr>
<tr class="memdesc:gae19d7ad84333f1a3f40ecbdbf639e017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process LSS communication.  <a href="group__CO__LSSslave.html#gae19d7ad84333f1a3f40ecbdbf639e017">More...</a><br /></td></tr>
<tr class="separator:gae19d7ad84333f1a3f40ecbdbf639e017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2692ff0d6837db494c029a3bef735ee7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__CO__LSS.html#gaaa9a270e40ea09850e1661e5aeb080ad">CO_LSS_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CO__LSSslave.html#ga2692ff0d6837db494c029a3bef735ee7">CO_LSSslave_getState</a> (<a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *LSSslave)</td></tr>
<tr class="memdesc:ga2692ff0d6837db494c029a3bef735ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current LSS state.  <a href="group__CO__LSSslave.html#ga2692ff0d6837db494c029a3bef735ee7">More...</a><br /></td></tr>
<tr class="separator:ga2692ff0d6837db494c029a3bef735ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c23178117a707046eb15ebc6506429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CO__LSSslave.html#ga64c23178117a707046eb15ebc6506429">CO_LSSslave_initCallbackPre</a> (<a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *LSSslave, void *object, void(*pFunctSignalPre)(void *object))</td></tr>
<tr class="memdesc:ga64c23178117a707046eb15ebc6506429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize LSSslaveRx callback function.  <a href="group__CO__LSSslave.html#ga64c23178117a707046eb15ebc6506429">More...</a><br /></td></tr>
<tr class="separator:ga64c23178117a707046eb15ebc6506429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665f147d6fae6db71173c4a8d602495c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CO__LSSslave.html#ga665f147d6fae6db71173c4a8d602495c">CO_LSSslave_initCheckBitRateCallback</a> (<a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *LSSslave, void *object, <a class="el" href="group__CO__dataTypes.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>(*pFunctLSScheckBitRate)(void *object, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> bitRate))</td></tr>
<tr class="memdesc:ga665f147d6fae6db71173c4a8d602495c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize verify bit rate callback.  <a href="group__CO__LSSslave.html#ga665f147d6fae6db71173c4a8d602495c">More...</a><br /></td></tr>
<tr class="separator:ga665f147d6fae6db71173c4a8d602495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0253fffcb36ab6b850563328784a8a5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CO__LSSslave.html#ga0253fffcb36ab6b850563328784a8a5a">CO_LSSslave_initActivateBitRateCallback</a> (<a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *LSSslave, void *object, void(*pFunctLSSactivateBitRate)(void *object, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> delay))</td></tr>
<tr class="memdesc:ga0253fffcb36ab6b850563328784a8a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize activate bit rate callback.  <a href="group__CO__LSSslave.html#ga0253fffcb36ab6b850563328784a8a5a">More...</a><br /></td></tr>
<tr class="separator:ga0253fffcb36ab6b850563328784a8a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc6187357904293da0a35317f15d0666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CO__LSSslave.html#gadc6187357904293da0a35317f15d0666">CO_LSSslave_initCfgStoreCallback</a> (<a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *LSSslave, void *object, <a class="el" href="group__CO__dataTypes.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>(*pFunctLSScfgStore)(void *object, <a class="el" href="group__CO__dataTypes.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> id, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> bitRate))</td></tr>
<tr class="memdesc:gadc6187357904293da0a35317f15d0666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store configuration callback.  <a href="group__CO__LSSslave.html#gadc6187357904293da0a35317f15d0666">More...</a><br /></td></tr>
<tr class="separator:gadc6187357904293da0a35317f15d0666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>CANopen Layer Setting Service - slave protocol.</p>
<p>The slave provides the following services</p><ul>
<li>node selection via LSS address</li>
<li>node selection via LSS fastscan</li>
<li>Inquire LSS address of currently selected node</li>
<li>Inquire node ID</li>
<li>Configure bit timing</li>
<li>Configure node ID</li>
<li>Activate bit timing parameters</li>
<li>Store configuration (bit rate and node ID)</li>
</ul>
<p>After CAN module start, the LSS slave and NMT slave are started and then coexist alongside each other. To achieve this behaviour, the CANopen node startup process has to be controlled more detailed. Therefore, <a class="el" href="group__CO__CANopen.html#ga3de87df54415e3c5c824eceff677f4a4" title="Initialize CANopen LSS slave.">CO_LSSinit()</a> must be invoked between <a class="el" href="group__CO__CANopen.html#gab33aa7899db750f1840ba64674f5fb5e" title="Initialize CAN driver.">CO_CANinit()</a> and <a class="el" href="group__CO__CANopen.html#gad85587d228b8ab0899a90c73ec0c7d9b" title="Initialize CANopenNode.">CO_CANopenInit()</a> in the communication reset section.</p>
<p>Moreover, the LSS slave needs to pause the NMT slave initialization in case no valid node ID is available at start up. In that case <a class="el" href="group__CO__CANopen.html#gad85587d228b8ab0899a90c73ec0c7d9b" title="Initialize CANopenNode.">CO_CANopenInit()</a> skips initialization of other CANopen modules and <a class="el" href="group__CO__CANopen.html#ga7a36da54b801074032622708e06a742e" title="Process CANopen objects.">CO_process()</a> skips processing of other modules than LSS slave automatically.</p>
<p>Variables for CAN-bitrate and CANopen node-id must be initialized by application from non-volatile memory or dip switches. Pointers to them are passed to <a class="el" href="group__CO__CANopen.html#ga3de87df54415e3c5c824eceff677f4a4" title="Initialize CANopen LSS slave.">CO_LSSinit()</a> function. Those variables represents pending values. If node-id is valid in the moment it enters <a class="el" href="group__CO__CANopen.html#ga3de87df54415e3c5c824eceff677f4a4" title="Initialize CANopen LSS slave.">CO_LSSinit()</a>, it also becomes active node-id and the stack initialises normally. Otherwise, node-id must be configured by lss and after successful configuration stack passes reset communication autonomously.</p>
<p>Device with all threads can be normally initialized and running despite that node-id is not valid. Application must take care, because CANopen is not initialized. In that case <a class="el" href="group__CO__CANopen.html#gad85587d228b8ab0899a90c73ec0c7d9b" title="Initialize CANopenNode.">CO_CANopenInit()</a> returns error condition CO_ERROR_NODE_ID_UNCONFIGURED_LSS which must be handled properly. Status can also be checked with CO-&gt;nodeIdUnconfigured variable.</p>
<p>Some callback functions may be initialized by application with <a class="el" href="group__CO__LSSslave.html#ga665f147d6fae6db71173c4a8d602495c" title="Initialize verify bit rate callback.">CO_LSSslave_initCheckBitRateCallback()</a>, <a class="el" href="group__CO__LSSslave.html#ga0253fffcb36ab6b850563328784a8a5a" title="Initialize activate bit rate callback.">CO_LSSslave_initActivateBitRateCallback()</a> and <a class="el" href="group__CO__LSSslave.html#gadc6187357904293da0a35317f15d0666" title="Store configuration callback.">CO_LSSslave_initCfgStoreCallback()</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaba1fafcd0024609f8a72be4810baf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaba1fafcd0024609f8a72be4810baf66">&#9670;&nbsp;</a></span>CO_LSSslave_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CO__driver.html#ga1cb2d3466eb0c6d267f3b5ff1a0d9532">CO_ReturnError_t</a> CO_LSSslave_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *&#160;</td>
          <td class="paramname"><em>LSSslave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionCO__LSS__address__t.html">CO_LSS_address_t</a> *&#160;</td>
          <td class="paramname"><em>lssAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> *&#160;</td>
          <td class="paramname"><em>pendingBitRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CO__dataTypes.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>pendingNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCO__CANmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANdevRx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>&#160;</td>
          <td class="paramname"><em>CANdevRxIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CO__dataTypes.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>&#160;</td>
          <td class="paramname"><em>CANidLssMaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCO__CANmodule__t.html">CO_CANmodule_t</a> *&#160;</td>
          <td class="paramname"><em>CANdevTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>&#160;</td>
          <td class="paramname"><em>CANdevTxIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CO__dataTypes.html#ga33594304e786b158f3fb30289278f5af">uint32_t</a>&#160;</td>
          <td class="paramname"><em>CANidLssSlave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize LSS object. </p>
<p>Function must be called in the communication reset section.</p>
<p>pendingBitRate and pendingNodeID must be pointers to external variables. Both variables must be initialized on program startup (after <a class="el" href="group__CO__NMT__Heartbeat.html#ggac396242e2e12ef6b0b22ff48636bc4ebaa8558d18a80148a598e6295ef41cdf97" title="Reset device.">CO_NMT_RESET_NODE</a>) from non-volatile memory, dip switches or similar. They must not change during <a class="el" href="group__CO__NMT__Heartbeat.html#ggac396242e2e12ef6b0b22ff48636bc4ebabc6aef9d84c816eecaea38f9fe2cbd9c" title="Reset CANopen communication on device.">CO_NMT_RESET_COMMUNICATION</a>. Both variables can be changed by <a class="el" href="group__CO__LSSslave.html#gae19d7ad84333f1a3f40ecbdbf639e017" title="Process LSS communication.">CO_LSSslave_process()</a>, depending on commands from the LSS master.</p>
<p>If pendingNodeID is valid (1 &lt;= pendingNodeID &lt;= 0x7F), then this becomes valid active nodeId just after exit of this function. In that case all other CANopen objects may be initialized and processed in run time.</p>
<p>If pendingNodeID is not valid (pendingNodeID == 0xFF), then only LSS slave is initialized and processed in run time. In that state pendingNodeID can be configured and after successful configuration reset communication with all CANopen object is activated automatically.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The LSS address needs to be unique on the network. For this, the 128 bit wide identity object (1018h) is used. Therefore, this object has to be fully initialized before passing it to this function (vendorID, product code, revisionNo, serialNo are set to 0 by default). Otherwise, if non-configured devices are present on CANopen network, LSS configuration may behave unpredictable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">LSSslave</td><td>This object will be initialized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lssAddress</td><td>LSS address </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pendingBitRate</td><td>Pending bit rate of the CAN interface </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pendingNodeID</td><td>Pending node ID or 0xFF - invalid </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CANdevRx</td><td>CAN device for LSS slave reception. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CANdevRxIdx</td><td>Index of receive buffer in the above CAN device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CANidLssMaster</td><td>COB ID for reception. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CANdevTx</td><td>CAN device for LSS slave transmission. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CANdevTxIdx</td><td>Index of transmit buffer in the above CAN device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CANidLssSlave</td><td>COB ID for transmission. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__CO__driver.html#ga1cb2d3466eb0c6d267f3b5ff1a0d9532" title="Return values of some CANopen functions.">CO_ReturnError_t</a>: CO_ERROR_NO or CO_ERROR_ILLEGAL_ARGUMENT. </dd></dl>

</div>
</div>
<a id="gae19d7ad84333f1a3f40ecbdbf639e017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae19d7ad84333f1a3f40ecbdbf639e017">&#9670;&nbsp;</a></span>CO_LSSslave_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CO__dataTypes.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a> CO_LSSslave_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *&#160;</td>
          <td class="paramname"><em>LSSslave</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process LSS communication. </p>
<p>Object is partially pre-processed after LSS message received. Further processing is inside this function.</p>
<p>In case that Node-Id is unconfigured, then this function may request CANopen communication reset. This happens, when valid node-id is configured by LSS master.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LSSslave</td><td>This object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if <a class="el" href="group__CO__NMT__Heartbeat.html#ggac396242e2e12ef6b0b22ff48636bc4ebabc6aef9d84c816eecaea38f9fe2cbd9c" title="Reset CANopen communication on device.">CO_NMT_RESET_COMMUNICATION</a> is requested </dd></dl>

</div>
</div>
<a id="ga2692ff0d6837db494c029a3bef735ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2692ff0d6837db494c029a3bef735ee7">&#9670;&nbsp;</a></span>CO_LSSslave_getState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__CO__LSS.html#gaaa9a270e40ea09850e1661e5aeb080ad">CO_LSS_state_t</a> CO_LSSslave_getState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *&#160;</td>
          <td class="paramname"><em>LSSslave</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current LSS state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LSSslave</td><td>This object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__CO__LSS.html#gaaa9a270e40ea09850e1661e5aeb080ad" title="LSS finite state automaton.">CO_LSS_state_t</a> </dd></dl>

</div>
</div>
<a id="ga64c23178117a707046eb15ebc6506429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c23178117a707046eb15ebc6506429">&#9670;&nbsp;</a></span>CO_LSSslave_initCallbackPre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_LSSslave_initCallbackPre </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *&#160;</td>
          <td class="paramname"><em>LSSslave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *object)&#160;</td>
          <td class="paramname"><em>pFunctSignalPre</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize LSSslaveRx callback function. </p>
<p>Function initializes optional callback function, which should immediately start further LSS processing. Callback is called after LSS message is received from the CAN bus. It should signal the RTOS to resume corresponding task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LSSslave</td><td>This object. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to object, which will be passed to pFunctSignal(). Can be NULL </td></tr>
    <tr><td class="paramname">pFunctSignalPre</td><td>Pointer to the callback function. Not called if NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga665f147d6fae6db71173c4a8d602495c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665f147d6fae6db71173c4a8d602495c">&#9670;&nbsp;</a></span>CO_LSSslave_initCheckBitRateCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_LSSslave_initCheckBitRateCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *&#160;</td>
          <td class="paramname"><em>LSSslave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CO__dataTypes.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>(*)(void *object, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> bitRate)&#160;</td>
          <td class="paramname"><em>pFunctLSScheckBitRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize verify bit rate callback. </p>
<p>Function initializes callback function, which is called when "config bit
timing parameters" is used. The callback function needs to check if the new bit rate is supported by the CANopen device. Callback returns "true" if supported. When no callback is set the LSS slave will no-ack the request, indicating to the master that bit rate change is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LSSslave</td><td>This object. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to object, which will be passed to pFunctLSScheckBitRate(). Can be NULL </td></tr>
    <tr><td class="paramname">pFunctLSScheckBitRate</td><td>Pointer to the callback function. Not called if NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0253fffcb36ab6b850563328784a8a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0253fffcb36ab6b850563328784a8a5a">&#9670;&nbsp;</a></span>CO_LSSslave_initActivateBitRateCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_LSSslave_initActivateBitRateCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *&#160;</td>
          <td class="paramname"><em>LSSslave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *object, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> delay)&#160;</td>
          <td class="paramname"><em>pFunctLSSactivateBitRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize activate bit rate callback. </p>
<p>Function initializes callback function, which is called when "activate bit
timing parameters" is used. The callback function gives the user an event to allow setting a timer or do calculations based on the exact time the request arrived. According to DSP 305 6.4.4, the delay has to be applied once before and once after switching bit rates. During this time, a device mustn't send any messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LSSslave</td><td>This object. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to object, which will be passed to pFunctLSSactivateBitRate(). Can be NULL </td></tr>
    <tr><td class="paramname">pFunctLSSactivateBitRate</td><td>Pointer to the callback function. Not called if NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc6187357904293da0a35317f15d0666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc6187357904293da0a35317f15d0666">&#9670;&nbsp;</a></span>CO_LSSslave_initCfgStoreCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CO_LSSslave_initCfgStoreCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCO__LSSslave__t.html">CO_LSSslave_t</a> *&#160;</td>
          <td class="paramname"><em>LSSslave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CO__dataTypes.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>(*)(void *object, <a class="el" href="group__CO__dataTypes.html#gaba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> id, <a class="el" href="group__CO__dataTypes.html#ga1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> bitRate)&#160;</td>
          <td class="paramname"><em>pFunctLSScfgStore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store configuration callback. </p>
<p>Function initializes callback function, which is called when "store configuration" is used. The callback function gives the user an event to store the corresponding node id and bit rate to NVM. Those values have to be supplied to the init function as "persistent values" after reset. If callback returns "true", success is send to the LSS master. When no callback is set the LSS slave will no-ack the request, indicating to the master that storing is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LSSslave</td><td>This object. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to object, which will be passed to pFunctLSScfgStore(). Can be NULL </td></tr>
    <tr><td class="paramname">pFunctLSScfgStore</td><td>Pointer to the callback function. Not called if NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Sep 19 2020 10:03:21 for CANopenNode by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
