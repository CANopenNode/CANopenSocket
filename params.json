{"name":"CANopenSocket","tagline":"CANopen implementation for Linux SocketCAN with master command interface.","body":"CANopenSocket\r\n=============\r\n\r\nCANopenSocket is a collection of CANopen tools running on Linux with socketCAN interface.\r\nIt is based on CANopenNode, which is an opensource [CANopen](http://can-cia.org/) Stack\r\n([CiA301](http://can-cia.org/standardization/technical-documents)) and is included as a git submodule.\r\n\r\nCANopenSocket may be used as a master or a slave device. However, CANopen itself is not a\r\ntypical master/slave protocol. It is more like producer/consumer protocol. It is also\r\npossible to operate CANopen network without a master. Pre-configured process data (PDO)\r\nare transmitted from producers. Each PDO may be consumed by multiple nodes.\r\n\r\nCANopen master of CANopenNode functionality contains command line interface with SDO and NMT master\r\ncommands. With SDO master (or SDO client) it is possible to read or write any variable on any device\r\non the CANopen Network. NMT master can start, stop or reset nodes.\r\n\r\nCANopenNode should run on any Linux machine. Examples below was tested on Debian based machines,\r\nincluding **Ubuntu**, **Beaglebone Black** and **Raspberry PI**. It is possible to run tests described\r\nbelow without real CAN interface, because Linux kernel already contains virtual CAN interface.\r\n\r\nCANopenSocket consists of two applocations: **canopend**, which runs in background, and\r\n**canopencomm**, command interface for SDO and NMT master.\r\n\r\n\r\n### canopend\r\n\r\n**canopend** is an implementation of CANopen device with master functionality. It runs within three\r\nthreads. Realtime thread processes CANopen SYNC and PDO objects. Mainline thread processes other\r\nnon time critical objects. Both are nonblocking. Command interface thread is blocking. It accepts\r\ncommands from socket connection from external application and executes master SDO and NMT tasks.\r\n\r\n\r\n### canopencomm\r\n**canopencomm** is the other end of the Command interface. It accepts text commands form arguments\r\nor from standard input or from file. It sends commands to *canopend* via socket, line after line.\r\nReceived result is printed to standard output. It is implementation of the CiA 309 standard.\r\n\r\n\r\nGetting started with CANopen Socket\r\n-----------------------------------\r\n\r\nWe will run two instances of *CANopend*. First will be basic node with ID=4,\r\nsecond, with nodeID = 3, will have master functionality.\r\n\r\n\r\n### Get the project\r\n\r\nClone the project from git repoitory and get submodules:\r\n\r\n    $ git clone https://github.com/CANopenNode/CANopenSocket.git\r\n    $ cd CANopenSocket\r\n    $ git submodule init\r\n    $ git submodule update\r\n\r\n(If you want to work on submodule CANopenNode, you can apply git commands directly on it:)\r\n\r\n    $ cd CANopenNode\r\n    $ git checkout master\r\n    $ git remote -v\r\n    $ git remote set-url origin {url-of-your-git-repository}\r\n    $ git remote add {yourName} {url-of-your-git-repository} # alternative\r\n    $ git pull ({yourName} {yourbranch})\r\n    $ # etc.\r\n\r\n\r\n### First terminal: CAN dump\r\n\r\nPrepare CAN virtual (or real) device:\r\n\r\n    $ sudo modprobe vcan\r\n    $ sudo ip link add dev vcan0 type vcan\r\n    $ sudo ip link set up vcan0\r\n\r\nRun candump from [can-utils](https://github.com/linux-can/can-utils):\r\n\r\n    $ sudo apt-get install can-utils\r\n    $ candump vcan0\r\n\r\nIt will show all CAN trafic on vcan0.\r\n\r\n\r\n### Second terminal: canopend\r\n\r\nStart second terminal, compile and start *canopend*.\r\n\r\n    $ cd CANopenSocket/canopend\r\n    $ make\r\n    $ ./canopend --help\r\n    $ ./canopend vcan0 -i 4 -s od4_storage -a od4_storage_auto\r\n\r\nYou should now see CAN messages on CAN dump terminal. Wait few seconds and\r\npress CTRL-C.\r\n\r\n    vcan0  704   [1]  00                        # Bootup message.\r\n    vcan0  084   [8]  00 50 01 2F F3 FF FF FF   # Emergency message.\r\n    vcan0  704   [1]  7F                        # Heartbeat messages\r\n    vcan0  704   [1]  7F                        # one per second.\r\n\r\nHeartbeat messages shows pre-operational state (0x7F). If you follow byte 4 of the\r\nEmergency message into [CANopenNode/stack/CO_Emergency.h],\r\nCO_EM_errorStatusBits, you will see under 0x2F \"CO_EM_NON_VOLATILE_MEMORY\",\r\nwhich is generic, critical error with access to non volatile device memory.\r\nThis byte is CANopenNode specific. You can observe also first two bytes,\r\nwhich shows standard error code (0x5000 - Device Hardware) or third byte,\r\nwhich shows error register. If error register is different than zero, then\r\nnode is not able to enter operational and PDOs can not be exchanged with it.\r\n\r\nYou can follow the reason of the problem inside the source code. However,\r\nthere are missing non-default storage files. Add them and run it again.\r\n\r\n    $ echo - > od4_storage\r\n    $ echo - > od4_storage_auto\r\n    $ ./canopend vcan0 -i 4 -s od4_storage -a od4_storage_auto\r\n\r\n    vcan0  704   [1]  00\r\n    vcan0  184   [2]  00 00                     # PDO message\r\n    vcan0  704   [1]  05\r\n\r\nNow there is operational state (0x05) and there shows one PDO on CAN\r\naddress 0x184. To learn more about PDOs, how to configure communication\r\nand mapping parameters and how to use them see other sources of CANopen\r\ndocumentation.\r\n\r\nStart also second instance of *canopend* (master on nodeID=3) in the same\r\nwindow (*canopend terminal*). Use default od_storage files and default\r\nsocket for command interface.\r\n\r\n    $ # press CTRL-Z\r\n    $ bg\r\n    $ ./canopend vcan0 -i 3 -c \"\"\r\n\r\n\r\n### Third terminal: canopencomm\r\n\r\nStart third terminal, compile and start canopencomm.\r\n\r\n    $ cd CANopenSocket/canopencomm\r\n    $ make\r\n    $ ./canopencomm --help\r\n\r\n#### SDO master\r\n\r\nPlay with it and also observe CAN dump teminal. First Hertbeat at\r\nindex 0x1017, subindex 0, 16-bit integer, on nodeID 4.\r\n\r\n    $ ./canopencomm [1] 4 read 0x1017 0 i16\r\n    $ ./canopencomm [1] 4 write 0x1017 0 i16 5000\r\n\r\nIn CAN dump you can see some SDO communication. You will notice, that\r\nHeartbeats from node 4 are coming in 5 second interval now. You can do\r\nthe same also for node 3. Now store Object dictionary, so it will preserve\r\nvariables on next start of the program.\r\n\r\n    $ ./canopencomm 4 w 0x1010 1 u32 0x65766173\r\n\r\nYou can read more about Object dictionary variables for this\r\nCANopenNode in [canopend/CANopenSocket.html].\r\n\r\n\r\n#### NMT master\r\nIf node is operational (started), it can exchange all objects, including\r\nPDO, SDO, etc. In pre-operational, PDOs are disabled, SDOs works. In stopped\r\nonly NMT messages are accepted.\r\n\r\n    $ ./canopencomm 4 preop\r\n    $ ./canopencomm 4 start\r\n    $ ./canopencomm 4 stop\r\n    $ ./canopencomm 4 r 0x1017 0 i16 \t\t# time out\r\n    $ ./canopencomm 4 reset communication\r\n    $ ./canopencomm 4 reset node\r\n    $ ./canopencomm 3 reset node\r\n\r\nIn *canopend terminal* you see, that both devices finished. Further commands\r\nare not possible. If you set so, last command can also reset computer.\r\n\r\n### Next steps\r\nNow you can learn more skills on CANopen from some other sources:\r\nbooks, data sheet of some CANopen device, standard CiA 301(it's free), etc.\r\nThen you can enter the big world of [CANopen devices](http://can-newsletter.org/hardware).\r\n\r\nWith [CANopenNode](https://github.com/CANopenNode/CANopenNode) you can also design your\r\nown device. There are many very useful and high quality specifications for different\r\n[device profiles](http://www.can-cia.org/standardization/specifications/),\r\nsome of them are public and free to download.\r\n\r\nHere we played with virtual CAN interface and result shows as pixels on\r\nscreen. If you connect real CAN interface to your computer, things may\r\nbecome dangerous. Keep control on your machines!\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}